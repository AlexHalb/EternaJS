Only in contrafold/src: Contrafold.o
Only in contrafold/src: Defaults.ipp
Only in contrafold/src: FileDescription.o
diff -X .gitignore -ur contrafold_stock/src/InferenceEngine.hpp contrafold/src/InferenceEngine.hpp
--- contrafold_stock/src/InferenceEngine.hpp	2020-04-25 05:36:40.000000000 -0700
+++ contrafold/src/InferenceEngine.hpp	2020-04-25 06:57:14.000000000 -0700
@@ -283,6 +283,7 @@
     // Viterbi inference
     void ComputeViterbi();
     RealT GetViterbiScore() const;
+    void GetViterbiFeatures();
     std::vector<int> PredictPairingsViterbi() const;
     std::vector<RealT> ComputeViterbiFeatureCounts();
 
Only in contrafold/src: InferenceEngine.hpp.orig
diff -X .gitignore -ur contrafold_stock/src/InferenceEngine.ipp contrafold/src/InferenceEngine.ipp
--- contrafold_stock/src/InferenceEngine.ipp	2020-04-25 05:36:40.000000000 -0700
+++ contrafold/src/InferenceEngine.ipp	2020-04-25 06:58:33.000000000 -0700
@@ -2,10 +2,13 @@
 // InferenceEngine.ipp
 //////////////////////////////////////////////////////////////////////
 
+void (*eos_cb)(int index, int fe);
+
 //////////////////////////////////////////////////////////////////////
 // Wrapper macros for certain model features.
 //////////////////////////////////////////////////////////////////////
 
+
 // score for leaving s[i] unpaired
 
 #if defined(HAMMING_LOSS)
@@ -4757,3 +4760,341 @@
         ret[i] = (posterior[i] >= posterior_cutoff ? posterior[i] : RealT(0));
     return ret;
 }
+
+//////////////////////////////////////////////////////////////////////
+// InferenceEngine::GetViterbiFeatures
+// 
+// Put features in eos_cb.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void InferenceEngine<RealT>::GetViterbiFeatures()
+{
+    std::queue<triple<int *,int,int> > traceback_queue;
+    traceback_queue.push(make_triple(&F5t[0], 0, L));
+
+    std::vector<triple<int, int, int> > multiloops;
+    ClearCounts();
+
+    std::map<int, RealT> eos_cb_map;
+    for (int k = -1; k <= L; k++){
+        eos_cb_map[k] = 0;
+    }
+
+    while (!traceback_queue.empty())
+    {
+        triple<int *,int,int> t = traceback_queue.front();
+        traceback_queue.pop();
+        const int *V = t.first;
+        const int i = t.second;
+        const int j = t.third;
+        
+        std::pair<int,int> traceback = DecodeTraceback (V == &F5t[0] ? V[j] : V[offset[i]+j]);
+        
+        //std::cout << (V == FCt ? "FC " : V == FMt ? "FM " : V == FM1t ? "FM1 " : "F5 ");
+        //std::cout << i << " " << j << ": " << traceback.first << " " << traceback.second << std::endl;
+        
+        switch (traceback.first)
+        {
+
+    // HWS: we're not using these params
+#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
+            case TB_FN_HAIRPIN: 
+                CountHairpin(i,j,RealT(1));
+                break;
+            case TB_FN_SINGLE: 
+            {
+                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+                CountSingle(i,j,p,q,RealT(1));
+
+                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
+            }
+            break;
+            case TB_FN_BIFURCATION:
+            {
+                const int k = traceback.second;
+                CountJunctionA(i,j,RealT(1));
+                CountMultiPaired(RealT(1));
+                CountMultiBase(RealT(1));
+
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+            case TB_FE_STACKING: 
+            {
+                CountBasePair(i+1,j,RealT(1));
+                CountHelixStacking(i,j+1,RealT(1));
+
+                traceback_queue.push(make_triple(&FEt[0], i+1, j-1));
+            }
+            break;
+            case TB_FE_FN: 
+            {
+                traceback_queue.push(make_triple(&FNt[0], i, j));
+            }
+            break;
+            case TB_FC_FN:
+            {
+                CountIsolated(RealT(1));
+                traceback_queue.push(make_triple(&FNt[0], i, j));
+            }
+            break;
+            case TB_FC_HELIX:
+            {
+                const int m = traceback.second;
+                CountHelix(i-1,j+1,m,RealT(1));
+                traceback_queue.push(make_triple(&FNt[0], i+m-1, j-m+1));
+            }
+            break;
+            case TB_FC_FE:
+            {
+                const int m = D_MAX_HELIX_LENGTH;
+                CountHelix(i-1,j+1,m,RealT(1));
+                traceback_queue.push(make_triple(&FEt[0], i+m-1, j-m+1));
+            }
+            break;
+
+    //HWS: our param sections start here
+#else
+            case TB_FC_HAIRPIN: 
+                CountHairpin(i,j,RealT(1));
+                //////////////////////////////////////////////////////////////////////
+                // InferenceEngine::ScoreHairpin()
+                // InferenceEngine::CountHairpin()
+                //
+                // Returns the score for a hairpin spanning positions i to j.
+                //
+                // In an RNA structure, this would look like
+                //
+                //                           ...
+                //                       /         \. 
+                //                   x[i+2]       x[j-1]
+                //                      |            |
+                //                   x[i+1]        x[j]
+                // position i -------->  o          o  <----- position j
+                //                      x[i] -- x[j+1]
+                //                        |        |
+                //                     x[i-1] -- x[j+2]
+                //
+                //////////////////////////////////////////////////////////////////////
+
+                //HWS: subtracting off 1 to get zero-indexing for eos_cb
+
+                //std::cerr << "Hairpin " << i-1 << " " << ScoreHairpin(i,j) << std::endl;
+                eos_cb_map[i-1] += ScoreHairpin(i,j);
+
+                break;
+            case TB_FC_SINGLE: 
+            {
+                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+
+                if (p == i && q == j)
+                {
+                    // CountBasePair(i+1,j,RealT(1));
+                    // CountHelixStacking(i,j+1,RealT(1));
+
+                //HWS: subtracting off 1 (from i+1) to get zero-indexing for eos_cb
+                //std::cerr << "BasePair " << i << " " << ScoreBasePair(i+1,j) << std::endl;
+                eos_cb_map[i] += ScoreBasePair(i+1,j);
+
+
+                // ScoreHelixStacking(i,j): score for a helix stacking pair of the form:
+                //
+                //       |         |
+                //    s[i+1] == s[j-1]
+                //       |         |
+                //     s[i] ==== s[j]
+                //       |         |
+                //HWS: subtracting off 1 (from i) to get zero-indexing for eos_cb
+
+                //std::cerr << "HelixStacking " << i-1 << " " << ScoreHelixStacking(i,j+1) << std::endl;
+                eos_cb_map[i-1] += ScoreHelixStacking(i,j+1);
+
+                }
+                else
+                {
+                   // CountSingle(i,j,p,q,RealT(1));
+                    //here we need to break this down because they sum a bunch of things to make ScoreSingle
+                    // here we need to subtract off the second base pair from ScoreSingle
+                // std::cerr << "Single " << i-1 << " " << ScoreSingle(i,j,p,q)-ScoreBasePair(p+1,q) << std::endl;
+                // std::cerr << "ScoreBasePair " << p << " " << ScoreBasePair(p+1,q) << std::endl;
+
+                eos_cb_map[i-1] += ScoreSingle(i,j,p,q)-ScoreBasePair(p+1,q);
+                eos_cb_map[p] += ScoreBasePair(p+1, q);
+
+                }
+                
+                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
+            }
+            break;
+            case TB_FC_BIFURCATION:
+            {
+                const int k = traceback.second;
+                // CountJunctionA(i,j,RealT(1));
+                // CountMultiPaired(RealT(1));
+                // CountMultiBase(RealT(1));
+
+                // This is where we first recognize we're in a new multiloop. Store the things at i
+                multiloops.push_back(make_triple(i,j,0));
+                // std::cerr << "New multiloop! " << i << ":" << j << std::endl;
+
+                // std::cerr << "FCBifurc:JunctionA " << i << " " << ScoreJunctionA(i,j) << std::endl;
+                // std::cerr << "FCBifurc:MultiPaired " << i << " " << ScoreMultiPaired() << std::endl;
+                // std::cerr << "FCBifurc:MultiBase " << i << " " << ScoreMultiBase() << std::endl;
+
+                eos_cb_map[i] += ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
+
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+#endif
+            case TB_FM1_PAIRED:
+            {
+                // CountJunctionA(j,i,RealT(1));
+                // CountMultiPaired(RealT(1));
+                // CountBasePair(i+1,j,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < i < multiloops[ind].second){
+                        if (i - multiloops[ind].first < min_dist){
+                            min_dist = i - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+
+                // These all go in the multiloop ind
+                //std::cerr << "Paired:JunctionA " << curr_multiloop_ind << " " << ScoreJunctionA(j,i) << std::endl;
+                //std::cerr << "Paired:MultiPaired " << curr_multiloop_ind << " " << ScoreMultiPaired() << std::endl;
+                
+                eos_cb_map[curr_multiloop_ind] += ScoreJunctionA(j,i) + ScoreMultiPaired();
+
+                //This just goes with the next base pair
+                //std::cerr << "Paired:BasePair " << i << " " << ScoreBasePair(i+1, j) << std::endl;
+                eos_cb_map[i] += ScoreBasePair(i+1, j);
+
+                traceback_queue.push(make_triple(&FCt[0], i+1, j-1));
+            }
+            break;
+            case TB_FM1_UNPAIRED:
+            {
+                // CountMultiUnpaired(i+1,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < i+1 < multiloops[ind].second){
+                        if (i+1 - multiloops[ind].first < min_dist){
+                            min_dist = i+1 - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
+                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(i+1) << std::endl;
+                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpaired(i+1);
+
+                traceback_queue.push(make_triple(&FM1t[0], i+1, j));
+            }
+            break;
+            case TB_FM_BIFURCATION:
+            {
+                const int k = traceback.second;
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+            case TB_FM_UNPAIRED:
+            {
+                //CountMultiUnpaired(j,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < j < multiloops[ind].second){
+                        if (j - multiloops[ind].first < min_dist){
+                            min_dist = j - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
+
+                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(j) << std::endl;
+                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpaired(j);
+
+                traceback_queue.push(make_triple(&FMt[0], i, j-1));
+            }
+            break;
+            case TB_FM_FM1: 
+                traceback_queue.push(make_triple(&FM1t[0], i, j));
+                break;
+            case TB_F5_ZERO:
+                break;
+            case TB_F5_UNPAIRED:
+                //CountExternalUnpaired(j,RealT(1));
+
+                // HWS: a score for unpaired things in the external loop, dump into the -1 eos_cb
+
+                //std::cerr << "ExternalUnpaired -1 " << ScoreExternalUnpaired(j) << std::endl;
+                eos_cb_map[-1] += ScoreExternalUnpaired(j);
+
+                traceback_queue.push(make_triple(&F5t[0], 0, j-1));
+                break;
+            case TB_F5_BIFURCATION:
+            {
+                const int k = traceback.second;
+                // CountExternalPaired(RealT(1));
+                // CountBasePair(k+1,j,RealT(1));
+                // CountJunctionA(j,k,RealT(1));
+                traceback_queue.push(make_triple(&F5t[0], 0, k));
+                traceback_queue.push(make_triple(&FCt[0], k+1, j-1));
+
+                //HWS: this is base pairs facing external loop. Hard-coding to print -1 as thinking these 
+                //should get summed in to the -1 "external loop " eos_cb category
+                
+                //std::cerr << "F5Bifurc:ExternalPaired -1 " << ScoreExternalPaired() << std::endl;
+                //std::cerr << "F5Bifurc:JunctionA -1 " << ScoreJunctionA(j,k) << std::endl;
+                eos_cb_map[-1] += ScoreExternalPaired()+ScoreJunctionA(j,k);
+
+                // HWS: another base pair, print (k+1) - 1 to zero-index
+                //std::cerr << "F5Bifurc:BasePair " << k << " " << ScoreBasePair(k+1, j) << std::endl;
+                eos_cb_map[k] += ScoreBasePair(k+1, j);
+
+            }
+            break;
+            default:
+                Assert(false, "Bad traceback.");
+        }
+    }
+    //RealT local_sum = 0;
+    //std::cout << "EOS_CB: ";
+    for (std::pair<int, RealT> element : eos_cb_map) {
+        if (element.first == -1 || element.second != 0){
+            if (eos_cb) (*eos_cb)(element.first, element.second);
+        //std::cout << element.first << ", " << element.second << ", ";
+        //local_sum += element.second;
+    }
+    }
+    //std::cout << std::endl;
+   // std::cout << "local sum " << local_sum << std::endl;
+
+}
Only in contrafold/src: InferenceEngine.ipp.orig
Only in contrafold/src: InferenceEngine.ipp.rej
Only in contrafold/src: LBFGS.ipp.orig
Only in contrafold/src: Options.o
diff -X .gitignore -ur contrafold_stock/src/ParameterManager.ipp contrafold/src/ParameterManager.ipp
--- contrafold_stock/src/ParameterManager.ipp	2020-04-25 05:36:40.000000000 -0700
+++ contrafold/src/ParameterManager.ipp	2020-04-25 06:43:38.000000000 -0700
@@ -2,7 +2,10 @@
 // ParameterManager.ipp
 //////////////////////////////////////////////////////////////////////
 
-#include "ParameterManager.hpp"
+#pragma once
+
+#ifndef PARAMETERMANAGER_IPP
+#define PARAMETERMANAGER_IPP
 
 //////////////////////////////////////////////////////////////////////
 // ParameterGroup::ParameterGroup()
@@ -266,3 +269,5 @@
     if (iter == physical_to_logical.end()) Error("Request for unknown physical parameter.");
     return iter->second;
 }
+
+#endif
diff -X .gitignore -ur contrafold_stock/src/SStruct.cpp contrafold/src/SStruct.cpp
--- contrafold_stock/src/SStruct.cpp	2020-04-25 05:36:40.000000000 -0700
+++ contrafold/src/SStruct.cpp	2020-04-25 06:47:28.000000000 -0700
@@ -60,6 +60,38 @@
     ValidateMapping(mapping);
 }
 
+// SStruct::LoadString()
+//
+// Load from string.
+//////////////////////////////////////////////////////////////////////
+
+void SStruct::LoadString(const std::string &string)
+{
+    // clear any previous data
+    std::vector<std::string>().swap(names);
+    std::vector<std::string>().swap(sequences);
+    std::vector<int>().swap(mapping);
+
+    // initialize
+    names.push_back("no_file");
+    sequences.push_back("@" + string);
+
+    // sanity-checks
+    if (sequences[0].length() == 1) Error("Zero-length sequence read.");
+
+    // initialize empty secondary structure
+    mapping.resize(sequences[0].length(), UNKNOWN);
+
+    // perform character conversions
+    for (size_t i = 0; i < sequences.size(); i++)
+        sequences[i] = FilterSequence(sequences[i]);
+
+    // error-checking
+    ValidateMapping(mapping);
+}
+
+//////////////////////////////////////////////////////////////////////
+
 //////////////////////////////////////////////////////////////////////
 // SStruct::AnalyzeFormat()
 //
diff -X .gitignore -ur contrafold_stock/src/SStruct.hpp contrafold/src/SStruct.hpp
--- contrafold_stock/src/SStruct.hpp	2020-04-25 05:36:40.000000000 -0700
+++ contrafold/src/SStruct.hpp	2020-04-25 06:56:08.000000000 -0700
@@ -40,9 +40,6 @@
     std::string FilterSequence(std::string sequence) const;
     std::string FilterParens(std::string sequence) const;
 
-    // convert a pseudoknot-free parenthesized structure to a mapping and back
-    std::vector<int> ConvertParensToMapping(const std::string &parens) const;
-    std::string ConvertMappingToParens(const std::vector<int> &mapping) const;
 
     // check that a (possibly pseudoknotted) mapping is valid
     void ValidateMapping(const std::vector<int> &mapping) const;
@@ -62,6 +59,10 @@
 
     // load sequence and struture from file
     void Load(const std::string &filename);
+    void LoadString(const std::string &seq);
+    // convert a pseudoknot-free parenthesized structure to a mapping and back
+    std::vector<int> ConvertParensToMapping(const std::string &parens) const;
+    std::string ConvertMappingToParens(const std::vector<int> &mapping) const;
 
     // assignment operator
     const SStruct& operator=(const SStruct &rhs);
Only in contrafold/src: SStruct.o
Only in contrafold/src: ScorePrediction.o
Only in contrafold/src: Utilities.hpp.orig
Only in contrafold/src: Utilities.o
Only in contrafold/src: contrafold
Only in contrafold/src: score_prediction
Only in contrafold: unit_test_structs
